"use client";
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  UploadButton: () => UploadButton,
  UploadDropzone: () => UploadDropzone,
  Uploader: () => Uploader,
  generateComponents: () => generateComponents
});
module.exports = __toCommonJS(src_exports);

// src/components/button.tsx
var import_react4 = require("react");
var import_tailwind_merge = require("tailwind-merge");
var import_client2 = require("uploadthing/client");

// src/useUploadThing.ts
var import_react3 = require("react");
var import_shared2 = require("@uploadthing/shared");
var import_client = require("uploadthing/client");

// src/utils/useEvent.ts
var import_react = __toESM(require("react"));
var noop = () => void 0;
var useInsertionEffect = typeof window !== "undefined" ? (
  // useInsertionEffect is available in React 18+
  import_react.default.useInsertionEffect || import_react.default.useLayoutEffect
) : noop;
function useEvent(callback) {
  const latestRef = import_react.default.useRef(
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    useEvent_shouldNotBeInvokedBeforeMount
  );
  useInsertionEffect(() => {
    latestRef.current = callback;
  }, [callback]);
  const stableRef = import_react.default.useRef();
  if (!stableRef.current) {
    stableRef.current = function() {
      return latestRef.current.apply(this, arguments);
    };
  }
  return stableRef.current;
}
function useEvent_shouldNotBeInvokedBeforeMount() {
  throw new Error(
    "INVALID_USEEVENT_INVOCATION: the callback from useEvent cannot be invoked before the component has mounted."
  );
}

// src/utils/useFetch.ts
var import_react2 = require("react");
var import_shared = require("@uploadthing/shared");
function useFetch(url, options) {
  const cache = (0, import_react2.useRef)({});
  const cancelRequest = (0, import_react2.useRef)(false);
  const initialState2 = {
    error: void 0,
    data: void 0
  };
  const fetchReducer = (state2, action) => {
    switch (action.type) {
      case "loading":
        return { ...initialState2 };
      case "fetched":
        return { ...initialState2, data: action.payload };
      case "error":
        return { ...initialState2, error: action.payload };
      default:
        return state2;
    }
  };
  const [state, dispatch] = (0, import_react2.useReducer)(fetchReducer, initialState2);
  (0, import_react2.useEffect)(() => {
    if (!url)
      return;
    cancelRequest.current = false;
    const fetchData = async () => {
      dispatch({ type: "loading" });
      if (cache.current[url]) {
        dispatch({ type: "fetched", payload: cache.current[url] });
        return;
      }
      try {
        const response = await fetch(url, options);
        if (!response.ok) {
          throw new Error(response.statusText);
        }
        const dataOrError = await (0, import_shared.safeParseJSON)(response);
        if (dataOrError instanceof Error) {
          throw dataOrError;
        }
        cache.current[url] = dataOrError;
        if (cancelRequest.current)
          return;
        dispatch({ type: "fetched", payload: dataOrError });
      } catch (error) {
        if (cancelRequest.current)
          return;
        dispatch({ type: "error", payload: error });
      }
    };
    void fetchData();
    return () => {
      cancelRequest.current = true;
    };
  }, [url]);
  return state;
}
var useFetch_default = useFetch;

// src/useUploadThing.ts
var useEndpointMetadata = (endpoint) => {
  var _a;
  const maybeServerData = globalThis.__UPLOADTHING;
  const { data } = useFetch_default(
    // Don't fetch if we already have the data
    maybeServerData ? void 0 : "/api/uploadthing"
  );
  return (_a = maybeServerData ?? data) == null ? void 0 : _a.find((x) => x.slug === endpoint);
};
var fatalClientError = (e) => new import_shared2.UploadThingError({
  code: "INTERNAL_CLIENT_ERROR",
  message: "Something went wrong. Please report this to UploadThing.",
  cause: e
});
var INTERNAL_uploadthingHookGen = () => {
  const useUploadThing = (endpoint, opts) => {
    const [isUploading, setUploading] = (0, import_react3.useState)(false);
    const uploadProgress = (0, import_react3.useRef)(0);
    const fileProgress = (0, import_react3.useRef)(/* @__PURE__ */ new Map());
    const permittedFileInfo = useEndpointMetadata(endpoint);
    const startUpload = useEvent(async (...args) => {
      var _a, _b, _c;
      const [files, input] = args;
      setUploading(true);
      (_a = opts == null ? void 0 : opts.onUploadProgress) == null ? void 0 : _a.call(opts, 0);
      try {
        const res = await (0, import_client.DANGEROUS__uploadFiles)({
          files,
          endpoint,
          input,
          onUploadProgress: (progress) => {
            var _a2;
            if (!(opts == null ? void 0 : opts.onUploadProgress))
              return;
            fileProgress.current.set(progress.file, progress.progress);
            let sum = 0;
            fileProgress.current.forEach((p) => {
              sum += p;
            });
            const averageProgress = Math.floor(sum / fileProgress.current.size / 10) * 10;
            if (averageProgress !== uploadProgress.current) {
              (_a2 = opts == null ? void 0 : opts.onUploadProgress) == null ? void 0 : _a2.call(opts, averageProgress);
              uploadProgress.current = averageProgress;
            }
          },
          onUploadBegin({ file }) {
            if (!(opts == null ? void 0 : opts.onUploadBegin))
              return;
            opts.onUploadBegin(file);
          }
        });
        (_b = opts == null ? void 0 : opts.onClientUploadComplete) == null ? void 0 : _b.call(opts, res);
        return res;
      } catch (e) {
        const error = e instanceof import_shared2.UploadThingError ? e : fatalClientError(e);
        (_c = opts == null ? void 0 : opts.onUploadError) == null ? void 0 : _c.call(
          opts,
          error
        );
      } finally {
        setUploading(false);
        fileProgress.current = /* @__PURE__ */ new Map();
        uploadProgress.current = 0;
      }
    });
    return {
      startUpload,
      isUploading,
      permittedFileInfo
    };
  };
  return useUploadThing;
};

// src/components/shared.tsx
var import_jsx_runtime = require("react/jsx-runtime");
function getFilesFromClipboardEvent(event) {
  var _a;
  const dataTransferItems = (_a = event.clipboardData) == null ? void 0 : _a.items;
  if (!dataTransferItems)
    return;
  const files = Array.from(dataTransferItems).reduce((acc, curr) => {
    const f = curr.getAsFile();
    return f ? [...acc, f] : acc;
  }, []);
  return files;
}
function Spinner() {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "svg",
    {
      className: "z-10 block h-5 w-5 animate-spin align-middle text-white",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 576 512",
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "path",
        {
          fill: "currentColor",
          d: "M256 32C256 14.33 270.3 0 288 0C429.4 0 544 114.6 544 256C544 302.6 531.5 346.4 509.7 384C500.9 399.3 481.3 404.6 465.1 395.7C450.7 386.9 445.5 367.3 454.3 351.1C470.6 323.8 480 291 480 255.1C480 149.1 394 63.1 288 63.1C270.3 63.1 256 49.67 256 31.1V32z"
        }
      )
    }
  );
}
var progressWidths = {
  0: "after:w-0",
  10: "after:w-[10%]",
  20: "after:w-[20%]",
  30: "after:w-[30%]",
  40: "after:w-[40%]",
  50: "after:w-[50%]",
  60: "after:w-[60%]",
  70: "after:w-[70%]",
  80: "after:w-[80%]",
  90: "after:w-[90%]",
  100: "after:w-[100%]"
};

// src/components/button.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
function UploadButton(props) {
  var _a, _b, _c, _d, _e;
  const $props = props;
  const { mode = "auto", appendOnPaste = false } = $props.config ?? {};
  const useUploadThing = INTERNAL_uploadthingHookGen();
  const fileInputRef = (0, import_react4.useRef)(null);
  const labelRef = (0, import_react4.useRef)(null);
  const [uploadProgressState, setUploadProgress] = (0, import_react4.useState)(
    $props.__internal_upload_progress ?? 0
  );
  const [files, setFiles] = (0, import_react4.useState)([]);
  const [isManualTriggerDisplayed, setIsManualTriggerDisplayed] = (0, import_react4.useState)(false);
  const uploadProgress = $props.__internal_upload_progress ?? uploadProgressState;
  const { startUpload, isUploading, permittedFileInfo } = useUploadThing(
    $props.endpoint,
    {
      onClientUploadComplete: (res) => {
        var _a2;
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setIsManualTriggerDisplayed(false);
        setFiles([]);
        (_a2 = $props.onClientUploadComplete) == null ? void 0 : _a2.call($props, res);
        setUploadProgress(0);
      },
      onUploadProgress: (p) => {
        var _a2;
        setUploadProgress(p);
        (_a2 = $props.onUploadProgress) == null ? void 0 : _a2.call($props, p);
      },
      onUploadError: $props.onUploadError,
      onUploadBegin: $props.onUploadBegin
    }
  );
  const { fileTypes, multiple } = (0, import_client2.generatePermittedFileTypes)(
    permittedFileInfo == null ? void 0 : permittedFileInfo.config
  );
  const ready = $props.__internal_ready ?? ($props.__internal_state === "ready" || fileTypes.length > 0);
  (0, import_react4.useEffect)(() => {
    const handlePaste = (event) => {
      if (!appendOnPaste)
        return;
      if (document.activeElement !== labelRef.current)
        return;
      const pastedFiles = getFilesFromClipboardEvent(event);
      if (!pastedFiles)
        return;
      setFiles((prev) => [...prev, ...pastedFiles]);
      if (mode === "auto") {
        const input = "input" in $props ? $props.input : void 0;
        void startUpload(files, input);
      }
    };
    window.addEventListener("paste", handlePaste);
    return () => {
      window.removeEventListener("paste", handlePaste);
    };
  }, [startUpload, appendOnPaste, $props, files, mode, fileTypes]);
  const getUploadButtonText = (fileTypes2) => {
    if (isManualTriggerDisplayed)
      return `Upload ${files.length} file${files.length === 1 ? "" : "s"}`;
    if (fileTypes2.length === 0)
      return "Loading...";
    return `Choose File${multiple ? `(s)` : ``}`;
  };
  const getInputProps = () => {
    var _a2;
    return {
      type: "file",
      ref: fileInputRef,
      multiple,
      accept: (_a2 = (0, import_client2.generateMimeTypes)(fileTypes ?? [])) == null ? void 0 : _a2.join(", "),
      onChange: (e) => {
        if (!e.target.files)
          return;
        const selectedFiles = Array.from(e.target.files);
        if (mode === "manual") {
          setFiles(selectedFiles);
          setIsManualTriggerDisplayed(true);
          return;
        }
        const input = "input" in $props ? $props.input : void 0;
        void startUpload(selectedFiles, input);
      },
      disabled: $props.__internal_button_disabled ?? !ready,
      ...!($props.__internal_button_disabled ?? !ready) ? { tabIndex: 0 } : {}
    };
  };
  const styleFieldArg = {
    ready,
    isUploading: $props.__internal_state === "uploading" || isUploading,
    uploadProgress,
    fileTypes
  };
  const state = (() => {
    if ($props.__internal_state)
      return $props.__internal_state;
    if (!ready)
      return "readying";
    if (ready && !isUploading)
      return "ready";
    return "uploading";
  })();
  const renderClearButton = () => {
    var _a2, _b2, _c2;
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
      "button",
      {
        onClick: () => {
          setFiles([]);
          setIsManualTriggerDisplayed(false);
          if (fileInputRef.current) {
            fileInputRef.current.value = "";
          }
        },
        className: (0, import_tailwind_merge.twMerge)(
          "h-[1.25rem] cursor-pointer rounded border-none bg-transparent text-gray-500 transition-colors hover:bg-slate-200 hover:text-gray-600",
          (0, import_client2.styleFieldToClassName)((_a2 = $props.appearance) == null ? void 0 : _a2.clearBtn, styleFieldArg)
        ),
        style: (0, import_client2.styleFieldToCssObject)((_b2 = $props.appearance) == null ? void 0 : _b2.clearBtn, styleFieldArg),
        "data-state": state,
        "data-ut-element": "clear-btn",
        children: (0, import_client2.contentFieldToContent)((_c2 = $props.content) == null ? void 0 : _c2.clearBtn, styleFieldArg) ?? "Clear"
      }
    );
  };
  const renderAllowedContent = () => {
    var _a2, _b2, _c2;
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
      "div",
      {
        className: (0, import_tailwind_merge.twMerge)(
          "h-[1.25rem]  text-xs leading-5 text-gray-600",
          (0, import_client2.styleFieldToClassName)((_a2 = $props.appearance) == null ? void 0 : _a2.allowedContent, styleFieldArg)
        ),
        style: (0, import_client2.styleFieldToCssObject)(
          (_b2 = $props.appearance) == null ? void 0 : _b2.allowedContent,
          styleFieldArg
        ),
        "data-state": state,
        "data-ut-element": "allowed-content",
        children: (0, import_client2.contentFieldToContent)((_c2 = $props.content) == null ? void 0 : _c2.allowedContent, styleFieldArg) ?? (0, import_client2.allowedContentTextLabelGenerator)(permittedFileInfo == null ? void 0 : permittedFileInfo.config)
      }
    );
  };
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
    "div",
    {
      className: (0, import_tailwind_merge.twMerge)(
        "flex flex-col items-center justify-center gap-1",
        $props.className,
        (0, import_client2.styleFieldToClassName)((_a = $props.appearance) == null ? void 0 : _a.container, styleFieldArg)
      ),
      style: (0, import_client2.styleFieldToCssObject)((_b = $props.appearance) == null ? void 0 : _b.container, styleFieldArg),
      "data-state": state,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
          "label",
          {
            className: (0, import_tailwind_merge.twMerge)(
              "relative flex h-10 w-36 cursor-pointer items-center justify-center overflow-hidden rounded-md text-white after:transition-[width] after:duration-500 focus-within:ring-2 focus-within:ring-blue-600 focus-within:ring-offset-2",
              state === "readying" && "cursor-not-allowed bg-blue-400",
              state === "uploading" && `bg-blue-400 after:absolute after:left-0 after:h-full after:bg-blue-600 after:content-[''] ${progressWidths[uploadProgress]}`,
              state === "ready" && "bg-blue-600",
              (0, import_client2.styleFieldToClassName)((_c = $props.appearance) == null ? void 0 : _c.button, styleFieldArg)
            ),
            style: (0, import_client2.styleFieldToCssObject)((_d = $props.appearance) == null ? void 0 : _d.button, styleFieldArg),
            "data-state": state,
            "data-ut-element": "button",
            tabIndex: 0,
            ref: labelRef,
            onClick: (e) => {
              if (isManualTriggerDisplayed) {
                e.preventDefault();
                e.stopPropagation();
                const input = "input" in $props ? $props.input : void 0;
                void startUpload(files, input);
              }
            },
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("input", { ...getInputProps(), className: "sr-only" }),
              (0, import_client2.contentFieldToContent)((_e = $props.content) == null ? void 0 : _e.button, styleFieldArg) ?? (state === "uploading" ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Spinner, {}) : getUploadButtonText(fileTypes))
            ]
          }
        ),
        mode === "manual" && files.length > 0 ? renderClearButton() : renderAllowedContent()
      ]
    }
  );
}

// src/components/dropzone.tsx
var import_react6 = require("react");
var import_tailwind_merge2 = require("tailwind-merge");
var import_client3 = require("uploadthing/client");

// src/use-dropzone/index.tsx
var import_react5 = require("react");
var import_file_selector = require("file-selector");

// src/use-dropzone/utils.ts
var import_attr_accept = __toESM(require("attr-accept"));
var accepts = (
  // @ts-expect-error - ESM interop
  typeof import_attr_accept.default === "function" ? import_attr_accept.default : import_attr_accept.default.default
);
var ErrorCode = {
  FILE_INVALID_TYPE: "FILE_INVALID_TYPE",
  FILE_TOO_LARGE: "FILE_TOO_LARGE",
  FILE_TOO_SMALL: "FILE_TOO_SMALL",
  TOO_MANY_FILES: "TOO_MANY_FILES"
};
var getInvalidTypeRejectionErr = (accept) => {
  accept = Array.isArray(accept) && accept.length === 1 ? accept[0] : accept;
  const messageSuffix = Array.isArray(accept) ? `one of ${accept.join(", ")}` : accept;
  return {
    code: ErrorCode.FILE_INVALID_TYPE,
    message: `File type must be ${messageSuffix}`
  };
};
var getTooLargeRejectionErr = (maxSize) => {
  return {
    code: ErrorCode.FILE_TOO_LARGE,
    message: `File is larger than ${maxSize} ${maxSize === 1 ? "byte" : "bytes"}`
  };
};
var getTooSmallRejectionErr = (minSize) => {
  return {
    code: ErrorCode.FILE_TOO_SMALL,
    message: `File is smaller than ${minSize} ${minSize === 1 ? "byte" : "bytes"}`
  };
};
function fileAccepted(file, accept) {
  const isAcceptable = file.type === "application/x-moz-file" || accepts(file, accept);
  return [
    isAcceptable,
    isAcceptable ? null : getInvalidTypeRejectionErr(accept)
  ];
}
function fileMatchSize(file, minSize, maxSize) {
  if (isDefined(file.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file.size > maxSize)
        return [false, getTooLargeRejectionErr(maxSize)];
      if (file.size < minSize)
        return [false, getTooSmallRejectionErr(minSize)];
    } else if (isDefined(minSize) && file.size < minSize)
      return [false, getTooSmallRejectionErr(minSize)];
    else if (isDefined(maxSize) && file.size > maxSize)
      return [false, getTooLargeRejectionErr(maxSize)];
  }
  return [true, null];
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function allFilesAccepted({
  files,
  accept,
  minSize,
  maxSize,
  multiple,
  maxFiles,
  validator
}) {
  if (!multiple && files.length > 1 || multiple && maxFiles >= 1 && files.length > maxFiles) {
    return false;
  }
  return files.every((file) => {
    const [accepted] = fileAccepted(file, accept);
    const [sizeMatch] = fileMatchSize(file, minSize, maxSize);
    const customErrors = validator ? validator(file) : null;
    return accepted && sizeMatch && !customErrors;
  });
}
function isPropagationStopped(event) {
  if ("isPropagationStopped" in event && typeof event.isPropagationStopped === "function") {
    return event.isPropagationStopped();
  } else if ("cancelBubble" in event && typeof event.cancelBubble !== "undefined") {
    return event.cancelBubble;
  }
  return false;
}
function isEvtWithFiles(event) {
  if (!("dataTransfer" in event && event.dataTransfer !== null)) {
    return !!event.target && "files" in event.target && !!event.target.files;
  }
  return Array.prototype.some.call(
    event.dataTransfer.types,
    (type) => type === "Files" || type === "application/x-moz-file"
  );
}
function onDocumentDragOver(event) {
  event.preventDefault();
}
function isIe(userAgent) {
  return userAgent.indexOf("MSIE") !== -1 || userAgent.indexOf("Trident/") !== -1;
}
function isEdge(userAgent) {
  return userAgent.indexOf("Edge/") !== -1;
}
function isIeOrEdge(userAgent = window.navigator.userAgent) {
  return isIe(userAgent) || isEdge(userAgent);
}
function composeEventHandlers(...fns) {
  return (event, ...args) => fns.some((fn) => {
    if (!isPropagationStopped(event) && fn) {
      fn(event, ...args);
    }
    return isPropagationStopped(event);
  });
}
function canUseFileSystemAccessAPI() {
  return "showOpenFilePicker" in window;
}
function pickerOptionsFromAccept(accept) {
  if (isDefined(accept)) {
    const acceptForPicker = Object.entries(accept).filter(([mimeType, ext]) => {
      let ok = true;
      if (!isMIMEType(mimeType)) {
        console.warn(
          `Skipped "${mimeType}" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.`
        );
        ok = false;
      }
      if (!Array.isArray(ext) || !ext.every(isExt)) {
        console.warn(
          `Skipped "${mimeType}" because an invalid file extension was provided.`
        );
        ok = false;
      }
      return ok;
    }).reduce(
      (agg, [mimeType, ext]) => ({
        ...agg,
        [mimeType]: ext
      }),
      {}
    );
    return [
      {
        // description is required due to https://crbug.com/1264708
        description: "Files",
        accept: acceptForPicker
      }
    ];
  }
  return accept;
}
function acceptPropAsAcceptAttr(accept) {
  if (isDefined(accept)) {
    return Object.entries(accept).reduce((a, [mimeType, ext]) => [...a, mimeType, ...ext], []).filter((v) => isMIMEType(v) || isExt(v)).join(",");
  }
  return void 0;
}
function isAbort(v) {
  return v instanceof DOMException && (v.name === "AbortError" || v.code === v.ABORT_ERR);
}
function isSecurityError(v) {
  return v instanceof DOMException && (v.name === "SecurityError" || v.code === v.SECURITY_ERR);
}
function isMIMEType(v) {
  return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
  return /^.*\.[\w]+$/.test(v);
}

// src/use-dropzone/index.tsx
var initialState = {
  isFocused: false,
  isFileDialogActive: false,
  isDragActive: false,
  isDragAccept: false,
  isDragReject: false,
  acceptedFiles: [],
  fileRejections: [],
  rootRef: (0, import_react5.createRef)(),
  inputRef: (0, import_react5.createRef)()
};
function useDropzone(props) {
  const {
    accept,
    disabled = false,
    getFilesFromEvent = import_file_selector.fromEvent,
    maxSize = Number.POSITIVE_INFINITY,
    minSize = 0,
    multiple = true,
    maxFiles = 0,
    onDragEnter,
    onDragLeave,
    onDragOver,
    onDrop,
    onDropAccepted,
    onDropRejected,
    onFileDialogCancel,
    onFileDialogOpen,
    useFsAccessApi,
    autoFocus,
    preventDropOnDocument = true,
    noClick = false,
    noKeyboard = false,
    noDrag = false,
    noDragEventsBubbling = false,
    onError,
    validator = null
  } = props;
  const acceptAttr = (0, import_react5.useMemo)(() => acceptPropAsAcceptAttr(accept), [accept]);
  const pickerTypes = (0, import_react5.useMemo)(() => pickerOptionsFromAccept(accept), [accept]);
  const onFileDialogOpenCb = (0, import_react5.useMemo)(
    () => typeof onFileDialogOpen === "function" ? onFileDialogOpen : noop2,
    [onFileDialogOpen]
  );
  const onFileDialogCancelCb = (0, import_react5.useMemo)(
    () => typeof onFileDialogCancel === "function" ? onFileDialogCancel : noop2,
    [onFileDialogCancel]
  );
  const rootRef = (0, import_react5.useRef)(null);
  const inputRef = (0, import_react5.useRef)(null);
  const [state, dispatch] = (0, import_react5.useReducer)(reducer, initialState);
  const { isFocused, isFileDialogActive } = state;
  const fsAccessApiWorksRef = (0, import_react5.useRef)(
    typeof window !== "undefined" && window.isSecureContext && useFsAccessApi && canUseFileSystemAccessAPI()
  );
  const onWindowFocus = () => {
    if (!fsAccessApiWorksRef.current && isFileDialogActive) {
      setTimeout(() => {
        if (inputRef.current) {
          const { files } = inputRef.current;
          if (!(files == null ? void 0 : files.length)) {
            dispatch({ type: "closeDialog" });
            onFileDialogCancelCb();
          }
        }
      }, 300);
    }
  };
  (0, import_react5.useEffect)(() => {
    window.addEventListener("focus", onWindowFocus, false);
    return () => {
      window.removeEventListener("focus", onWindowFocus, false);
    };
  }, [inputRef, isFileDialogActive, onFileDialogCancelCb, fsAccessApiWorksRef]);
  const dragTargetsRef = (0, import_react5.useRef)([]);
  const onDocumentDrop = (event) => {
    var _a;
    if ((_a = rootRef.current) == null ? void 0 : _a.contains(event.target)) {
      return;
    }
    event.preventDefault();
    dragTargetsRef.current = [];
  };
  (0, import_react5.useEffect)(() => {
    if (preventDropOnDocument) {
      document.addEventListener("dragover", onDocumentDragOver, false);
      document.addEventListener("drop", onDocumentDrop, false);
    }
    return () => {
      if (preventDropOnDocument) {
        document.removeEventListener("dragover", onDocumentDragOver);
        document.removeEventListener("drop", onDocumentDrop);
      }
    };
  }, [rootRef, preventDropOnDocument]);
  (0, import_react5.useEffect)(() => {
    if (!disabled && autoFocus && rootRef.current) {
      rootRef.current.focus();
    }
    return noop2;
  }, [rootRef, autoFocus, disabled]);
  const onErrCb = (0, import_react5.useCallback)(
    (e) => {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
    },
    [onError]
  );
  const onDragEnterCb = (0, import_react5.useCallback)(
    (event) => {
      event.preventDefault();
      event.persist();
      stopPropagation(event);
      dragTargetsRef.current = [...dragTargetsRef.current, event.target];
      if (isEvtWithFiles(event)) {
        Promise.resolve(getFilesFromEvent(event)).then((files) => {
          if (isPropagationStopped(event) && !noDragEventsBubbling) {
            return;
          }
          const fileCount = files.length;
          const isDragAccept = fileCount > 0 && allFilesAccepted({
            files,
            accept: acceptAttr,
            minSize,
            maxSize,
            multiple,
            maxFiles,
            validator
          });
          const isDragReject = fileCount > 0 && !isDragAccept;
          dispatch({
            type: "setDraggedFiles",
            payload: {
              isDragAccept,
              isDragReject,
              isDragActive: true
            }
          });
          if (onDragEnter) {
            onDragEnter(event);
          }
        }).catch(onErrCb);
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      getFilesFromEvent,
      onDragEnter,
      onErrCb,
      noDragEventsBubbling,
      acceptAttr,
      minSize,
      maxSize,
      multiple,
      maxFiles,
      validator
    ]
  );
  const onDragOverCb = (0, import_react5.useCallback)(
    (event) => {
      event.preventDefault();
      event.persist();
      stopPropagation(event);
      const hasFiles = isEvtWithFiles(event);
      if (hasFiles && "dataTransfer" in event && event.dataTransfer !== null) {
        try {
          event.dataTransfer.dropEffect = "copy";
        } catch {
        }
      }
      if (hasFiles && onDragOver) {
        onDragOver(event);
      }
      return false;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [onDragOver, noDragEventsBubbling]
  );
  const onDragLeaveCb = (0, import_react5.useCallback)(
    (event) => {
      event.preventDefault();
      event.persist();
      stopPropagation(event);
      const targets = dragTargetsRef.current.filter(
        (target) => {
          var _a;
          return (_a = rootRef.current) == null ? void 0 : _a.contains(target);
        }
      );
      const targetIdx = targets.indexOf(event.target);
      if (targetIdx !== -1) {
        targets.splice(targetIdx, 1);
      }
      dragTargetsRef.current = targets;
      if (targets.length > 0) {
        return;
      }
      dispatch({
        type: "setDraggedFiles",
        payload: {
          isDragActive: false,
          isDragAccept: false,
          isDragReject: false
        }
      });
      if (isEvtWithFiles(event) && onDragLeave) {
        onDragLeave(event);
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [rootRef, onDragLeave, noDragEventsBubbling]
  );
  const setFiles = (0, import_react5.useCallback)(
    (files, event) => {
      const acceptedFiles = [];
      const fileRejections = [];
      files.forEach((file) => {
        const [accepted, acceptError] = fileAccepted(file, acceptAttr);
        const [sizeMatch, sizeError] = fileMatchSize(file, minSize, maxSize);
        const customErrors = validator ? validator(file) : null;
        if (accepted && sizeMatch && !customErrors) {
          acceptedFiles.push(file);
        } else {
          let errors = [acceptError, sizeError];
          if (customErrors) {
            errors = errors.concat(customErrors);
          }
          fileRejections.push({
            file,
            errors: errors.filter((e) => !!e)
          });
        }
      });
      if (!multiple && acceptedFiles.length > 1 || multiple && maxFiles >= 1 && acceptedFiles.length > maxFiles) {
        acceptedFiles.forEach((file) => {
          fileRejections.push({
            file,
            errors: [
              { code: ErrorCode.TOO_MANY_FILES, message: "Too many files" }
            ]
          });
        });
        acceptedFiles.splice(0);
      }
      dispatch({
        type: "setFiles",
        payload: {
          acceptedFiles,
          fileRejections
        }
      });
      if (onDrop) {
        onDrop(acceptedFiles, fileRejections, event);
      }
      if (fileRejections.length > 0 && onDropRejected) {
        onDropRejected(fileRejections, event);
      }
      if (acceptedFiles.length > 0 && onDropAccepted) {
        onDropAccepted(acceptedFiles, event);
      }
    },
    [
      dispatch,
      multiple,
      acceptAttr,
      minSize,
      maxSize,
      maxFiles,
      onDrop,
      onDropAccepted,
      onDropRejected,
      validator
    ]
  );
  const onDropCb = (0, import_react5.useCallback)(
    (event) => {
      event.preventDefault();
      event.persist();
      stopPropagation(event);
      dragTargetsRef.current = [];
      if (isEvtWithFiles(event)) {
        Promise.resolve(getFilesFromEvent(event)).then((files) => {
          if (isPropagationStopped(event) && !noDragEventsBubbling) {
            return;
          }
          setFiles(files, event);
        }).catch(onErrCb);
      }
      dispatch({ type: "reset" });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [getFilesFromEvent, setFiles, onErrCb, noDragEventsBubbling]
  );
  const openFileDialog = (0, import_react5.useCallback)(() => {
    if (fsAccessApiWorksRef.current) {
      dispatch({ type: "openDialog" });
      onFileDialogOpenCb();
      const opts = {
        multiple,
        types: pickerTypes
      };
      window.showOpenFilePicker(opts).then((handles) => getFilesFromEvent(handles)).then((files) => {
        setFiles(files, null);
        dispatch({ type: "closeDialog" });
      }).catch((e) => {
        if (isAbort(e)) {
          onFileDialogCancelCb();
          dispatch({ type: "closeDialog" });
        } else if (isSecurityError(e)) {
          fsAccessApiWorksRef.current = false;
          if (inputRef.current) {
            inputRef.current.value = "";
            inputRef.current.click();
          } else {
            onErrCb(
              new Error(
                "Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."
              )
            );
          }
        } else {
          onErrCb(e);
        }
      });
      return;
    }
    if (inputRef.current) {
      dispatch({ type: "openDialog" });
      onFileDialogOpenCb();
      inputRef.current.value = "";
      inputRef.current.click();
    }
  }, [
    dispatch,
    onFileDialogOpenCb,
    onFileDialogCancelCb,
    useFsAccessApi,
    setFiles,
    onErrCb,
    pickerTypes,
    multiple
  ]);
  const onKeyDownCb = (0, import_react5.useCallback)(
    (event) => {
      var _a;
      if (!((_a = rootRef.current) == null ? void 0 : _a.isEqualNode(event.target))) {
        return;
      }
      if ("key" in event && (event.key === " " || event.key === "Enter") || "keyCode" in event && (event.keyCode === 32 || event.keyCode === 13)) {
        event.preventDefault();
        openFileDialog();
      }
    },
    [rootRef, openFileDialog]
  );
  const onFocusCb = (0, import_react5.useCallback)(() => {
    dispatch({ type: "focus" });
  }, []);
  const onBlurCb = (0, import_react5.useCallback)(() => {
    dispatch({ type: "blur" });
  }, []);
  const onClickCb = (0, import_react5.useCallback)(() => {
    if (noClick) {
      return;
    }
    if (isIeOrEdge()) {
      setTimeout(openFileDialog, 0);
    } else {
      openFileDialog();
    }
  }, [noClick, openFileDialog]);
  const composeHandler = (fn) => {
    return disabled ? null : fn;
  };
  const composeKeyboardHandler = (fn) => {
    return noKeyboard ? null : composeHandler(fn);
  };
  const composeDragHandler = (fn) => {
    return noDrag ? null : composeHandler(fn);
  };
  const stopPropagation = (event) => {
    if (noDragEventsBubbling) {
      event.stopPropagation();
    }
  };
  const getRootProps = (0, import_react5.useMemo)(
    () => (
      // @ts-expect-error - FIXME LATER
      ({
        refKey = "ref",
        role,
        onKeyDown,
        onFocus,
        onBlur,
        onClick,
        onDragEnter: onDragEnter2,
        onDragOver: onDragOver2,
        onDragLeave: onDragLeave2,
        onDrop: onDrop2,
        ...rest
      } = {}) => ({
        onKeyDown: composeKeyboardHandler(
          composeEventHandlers(onKeyDown, onKeyDownCb)
        ),
        onFocus: composeKeyboardHandler(
          composeEventHandlers(onFocus, onFocusCb)
        ),
        onBlur: composeKeyboardHandler(composeEventHandlers(onBlur, onBlurCb)),
        onClick: composeHandler(composeEventHandlers(onClick, onClickCb)),
        onDragEnter: composeDragHandler(
          composeEventHandlers(onDragEnter2, onDragEnterCb)
        ),
        onDragOver: composeDragHandler(
          composeEventHandlers(onDragOver2, onDragOverCb)
        ),
        onDragLeave: composeDragHandler(
          composeEventHandlers(onDragLeave2, onDragLeaveCb)
        ),
        onDrop: composeDragHandler(composeEventHandlers(onDrop2, onDropCb)),
        role: typeof role === "string" && role !== "" ? role : "presentation",
        [refKey]: rootRef,
        ...!disabled && !noKeyboard ? { tabIndex: 0 } : {},
        ...rest
      })
    ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      rootRef,
      onKeyDownCb,
      onFocusCb,
      onBlurCb,
      onClickCb,
      onDragEnterCb,
      onDragOverCb,
      onDragLeaveCb,
      onDropCb,
      noKeyboard,
      noDrag,
      disabled
    ]
  );
  const onInputElementClick = (0, import_react5.useCallback)((event) => {
    event.stopPropagation();
  }, []);
  const getInputProps = (0, import_react5.useMemo)(
    () => (
      // @ts-expect-error - FIXME LATER
      ({ refKey = "ref", onChange, onClick, ...rest } = {}) => ({
        accept: acceptAttr,
        multiple,
        type: "file",
        style: { display: "none" },
        onChange: composeHandler(composeEventHandlers(onChange, onDropCb)),
        onClick: composeHandler(
          composeEventHandlers(onClick, onInputElementClick)
        ),
        tabIndex: -1,
        [refKey]: inputRef,
        ...rest
      })
    ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [inputRef, accept, multiple, onDropCb, disabled]
  );
  return {
    ...state,
    isFocused: isFocused && !disabled,
    getRootProps,
    getInputProps,
    rootRef,
    inputRef,
    open: composeHandler(openFileDialog)
  };
}
function reducer(state, action) {
  switch (action.type) {
    case "focus":
      return {
        ...state,
        isFocused: true
      };
    case "blur":
      return {
        ...state,
        isFocused: false
      };
    case "openDialog":
      return {
        ...initialState,
        isFileDialogActive: true
      };
    case "closeDialog":
      return {
        ...state,
        isFileDialogActive: false
      };
    case "setDraggedFiles":
      return {
        ...state,
        ...action.payload
      };
    case "setFiles":
      return {
        ...state,
        ...action.payload
      };
    case "reset":
      return {
        ...initialState
      };
    default:
      return state;
  }
}
function noop2() {
}

// src/components/dropzone.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
function UploadDropzone(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const $props = props;
  const { mode = "manual", appendOnPaste = false } = $props.config ?? {};
  const useUploadThing = INTERNAL_uploadthingHookGen();
  const [files, setFiles] = (0, import_react6.useState)([]);
  const [uploadProgressState, setUploadProgress] = (0, import_react6.useState)(
    $props.__internal_upload_progress ?? 0
  );
  const uploadProgress = $props.__internal_upload_progress ?? uploadProgressState;
  const { startUpload, isUploading, permittedFileInfo } = useUploadThing(
    $props.endpoint,
    {
      onClientUploadComplete: (res) => {
        var _a2;
        setFiles([]);
        (_a2 = $props.onClientUploadComplete) == null ? void 0 : _a2.call($props, res);
        setUploadProgress(0);
      },
      onUploadProgress: (p) => {
        var _a2;
        setUploadProgress(p);
        (_a2 = $props.onUploadProgress) == null ? void 0 : _a2.call($props, p);
      },
      onUploadError: $props.onUploadError,
      onUploadBegin: $props.onUploadBegin
    }
  );
  const { fileTypes } = (0, import_client3.generatePermittedFileTypes)(permittedFileInfo == null ? void 0 : permittedFileInfo.config);
  const onDrop = (0, import_react6.useCallback)(
    (acceptedFiles) => {
      setFiles(acceptedFiles);
      if (mode === "auto") {
        const input = "input" in $props ? $props.input : void 0;
        void startUpload(acceptedFiles, input);
        return;
      }
    },
    [$props, mode, startUpload]
  );
  const { getRootProps, getInputProps, isDragActive, rootRef } = useDropzone({
    onDrop,
    accept: fileTypes ? (0, import_client3.generateClientDropzoneAccept)(fileTypes) : void 0,
    disabled: $props.__internal_dropzone_disabled
  });
  const ready = $props.__internal_ready ?? ($props.__internal_state === "ready" || fileTypes.length > 0);
  const onUploadClick = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (!files)
      return;
    const input = "input" in $props ? $props.input : void 0;
    void startUpload(files, input);
  };
  (0, import_react6.useEffect)(() => {
    const handlePaste = (event) => {
      if (!appendOnPaste)
        return;
      if (document.activeElement !== rootRef.current)
        return;
      const pastedFiles = getFilesFromClipboardEvent(event);
      if (!pastedFiles)
        return;
      setFiles((prev) => [...prev, ...pastedFiles]);
      if (mode === "auto") {
        const input = "input" in $props ? $props.input : void 0;
        void startUpload(files, input);
      }
    };
    window.addEventListener("paste", handlePaste);
    return () => {
      window.removeEventListener("paste", handlePaste);
    };
  }, [startUpload, $props, appendOnPaste, mode, fileTypes, rootRef, files]);
  const styleFieldArg = {
    fileTypes,
    isDragActive,
    isUploading,
    ready,
    uploadProgress
  };
  const state = (() => {
    if ($props.__internal_state)
      return $props.__internal_state;
    if (!ready)
      return "readying";
    if (ready && !isUploading)
      return "ready";
    return "uploading";
  })();
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(
    "div",
    {
      className: (0, import_tailwind_merge2.twMerge)(
        "mt-2 flex flex-col items-center justify-center rounded-lg border border-dashed border-gray-900/25 px-6 py-10 text-center",
        isDragActive && "bg-blue-600/10",
        $props.className,
        (0, import_client3.styleFieldToClassName)((_a = $props.appearance) == null ? void 0 : _a.container, styleFieldArg)
      ),
      ...getRootProps(),
      style: (0, import_client3.styleFieldToCssObject)((_b = $props.appearance) == null ? void 0 : _b.container, styleFieldArg),
      "data-state": state,
      children: [
        (0, import_client3.contentFieldToContent)((_c = $props.content) == null ? void 0 : _c.uploadIcon, styleFieldArg) ?? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 20 20",
            className: (0, import_tailwind_merge2.twMerge)(
              "mx-auto block h-12 w-12 align-middle text-gray-400",
              (0, import_client3.styleFieldToClassName)((_d = $props.appearance) == null ? void 0 : _d.uploadIcon, styleFieldArg)
            ),
            style: (0, import_client3.styleFieldToCssObject)(
              (_e = $props.appearance) == null ? void 0 : _e.uploadIcon,
              styleFieldArg
            ),
            "data-ut-element": "upload-icon",
            "data-state": state,
            children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
              "path",
              {
                fill: "currentColor",
                fillRule: "evenodd",
                d: "M5.5 17a4.5 4.5 0 0 1-1.44-8.765a4.5 4.5 0 0 1 8.302-3.046a3.5 3.5 0 0 1 4.504 4.272A4 4 0 0 1 15 17H5.5Zm3.75-2.75a.75.75 0 0 0 1.5 0V9.66l1.95 2.1a.75.75 0 1 0 1.1-1.02l-3.25-3.5a.75.75 0 0 0-1.1 0l-3.25 3.5a.75.75 0 1 0 1.1 1.02l1.95-2.1v4.59Z",
                clipRule: "evenodd"
              }
            )
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(
          "label",
          {
            htmlFor: "file-upload",
            className: (0, import_tailwind_merge2.twMerge)(
              (0, import_client3.classNames)(
                "relative mt-4 flex w-64 cursor-pointer items-center justify-center text-sm font-semibold leading-6 text-gray-600 focus-within:outline-none focus-within:ring-2 focus-within:ring-blue-600 focus-within:ring-offset-2 hover:text-blue-500",
                ready ? "text-blue-600" : "text-gray-500"
              ),
              (0, import_client3.styleFieldToClassName)((_f = $props.appearance) == null ? void 0 : _f.label, styleFieldArg)
            ),
            style: (0, import_client3.styleFieldToCssObject)((_g = $props.appearance) == null ? void 0 : _g.label, styleFieldArg),
            "data-ut-element": "label",
            "data-state": state,
            children: [
              (0, import_client3.contentFieldToContent)((_h = $props.content) == null ? void 0 : _h.label, styleFieldArg) ?? (ready ? `Choose files or drag and drop` : `Loading...`),
              /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("input", { className: "sr-only", ...getInputProps() })
            ]
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          "div",
          {
            className: (0, import_tailwind_merge2.twMerge)(
              "m-0 h-[1.25rem] text-xs leading-5 text-gray-600",
              (0, import_client3.styleFieldToClassName)(
                (_i = $props.appearance) == null ? void 0 : _i.allowedContent,
                styleFieldArg
              )
            ),
            style: (0, import_client3.styleFieldToCssObject)(
              (_j = $props.appearance) == null ? void 0 : _j.allowedContent,
              styleFieldArg
            ),
            "data-ut-element": "allowed-content",
            "data-state": state,
            children: (0, import_client3.contentFieldToContent)((_k = $props.content) == null ? void 0 : _k.allowedContent, styleFieldArg) ?? (0, import_client3.allowedContentTextLabelGenerator)(permittedFileInfo == null ? void 0 : permittedFileInfo.config)
          }
        ),
        ($props.__internal_show_button ?? files.length > 0) && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          "button",
          {
            className: (0, import_tailwind_merge2.twMerge)(
              (0, import_client3.classNames)(
                "relative mt-4 flex h-10 w-36 items-center justify-center overflow-hidden rounded-md text-white after:transition-[width] after:duration-500",
                state === "uploading" ? `bg-blue-400 after:absolute after:left-0 after:h-full after:bg-blue-600 ${progressWidths[uploadProgress]}` : "bg-blue-600"
              ),
              (0, import_client3.styleFieldToClassName)((_l = $props.appearance) == null ? void 0 : _l.button, styleFieldArg)
            ),
            style: (0, import_client3.styleFieldToCssObject)(
              (_m = $props.appearance) == null ? void 0 : _m.button,
              styleFieldArg
            ),
            onClick: onUploadClick,
            "data-ut-element": "button",
            "data-state": state,
            disabled: $props.__internal_button_disabled ?? state === "uploading",
            children: (0, import_client3.contentFieldToContent)((_n = $props.content) == null ? void 0 : _n.button, styleFieldArg) ?? (state === "uploading" ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Spinner, {}) : `Upload ${files.length} file${files.length === 1 ? "" : "s"}`)
          }
        )
      ]
    }
  );
}

// src/component.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
function Uploader(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "flex flex-col items-center justify-center gap-4", children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: "text-center text-4xl font-bold", children: `Upload a file using a button:` }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(UploadButton, { ...props })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "flex flex-col items-center justify-center gap-4", children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: "text-center text-4xl font-bold", children: `...or using a dropzone:` }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(UploadDropzone, { ...props })
    ] })
  ] });
}
function generateComponents() {
  return {
    UploadButton,
    UploadDropzone,
    Uploader
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  UploadButton,
  UploadDropzone,
  Uploader,
  generateComponents
});
//# sourceMappingURL=index.js.map